#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <pthread.h>
#include <thread>
#include <chrono>

#include "msg_sender.h"
#include "server_exceptions.h"

#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include "opencv2/opencv.hpp"

bool handle_camera;
int keyboard;

using namespace cv;

void* cameraHandler( void * s )
{
	Mat frame; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	const int movement_threshold = 5000;
	int i = 0;
	MessageSender *sender = (MessageSender*) s ;
	VideoCapture capture(0);
	auto pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	pMOG2->setShadowValue(0);
	int start, end;
	start = clock();
	while( handle_camera ) {
		while( handle_camera && !capture.isOpened()  )
		{
			std::cout << "Unable to open camera" << endl;
			std::this_thread::sleep_for(1s);
			capture = VideoCapture(0);
		}
		while( handle_camera )
		{
			//read the current frame
			if(!capture.read(frame))
			{
				cerr << "Unable to read next frame." << endl;
				break;
			}
			pMOG2->apply(frame, fgMaskMOG2, 0.01);

			if( (char)keyboard == 'a' ) {
				pMOG2->apply(frame, fgMaskMOG2, 1);
			}
			GaussianBlur(frame, frame, Size(9, 9), 2, 2 );

			Mat gray = fgMaskMOG2.clone();
			Mat element = Mat::ones(5,5,CV_8UC1);

			// Apply the specified morphology operation
			morphologyEx( gray, gray, MORPH_CLOSE, element, Point(2,2), 2);
			morphologyEx( gray, gray, MORPH_OPEN, element, Point(2,2), 2);
			int non_zero = countNonZero( gray );
			end = clock();
			if( non_zero > movement_threshold && ( end - start ) > CLOCKS_PER_SEC ) {
				std::cout<<"Movement found!"<<std::endl;
				Message m;
				m.commandName = "auth";
				m.params["login"] = "a";
				m.params["a"] = "b";
				m.params["c"] = "d";
				sender->pushQueueMessage(m);
				sender->notifyAll();
				std::cout<<"Message pushed "<<m.toString()<<std::endl;
				start = clock();
			}
			imshow( "Result window", gray );
			imshow("Frame", frame);
			imshow("FG Mask MOG 2", fgMaskMOG2);

			waitKey( 30 );
		}
	}
}


void* send( void *  s)
{
	MessageSender *sender = (MessageSender*) s ;
	try {
		while( 1 )
		{
			try{
			sender->sendMessage();
			std::cout<<"Message sent"<<std::endl;
			}
			catch( ServerDisconnected& e ) {
				std::cout<<"Server disconnected!"<<std::endl;
				return 0;
			}
		}
	}
	catch( ServerClosingSignal& e ) {
		std::cout<<"Received server closing signal"<<std::endl;
		return 0;
	}
}


void* receive( void * s)
{
	using namespace std::chrono_literals;
	MessageSender *sender = (MessageSender*) s;
	std::string address = "192.168.43.141";
	pthread_t send_thread;

	try {
		while( 1 )
		{
			while( !sender->connect( address.c_str(), 9001, 1 ) ) {
				std::this_thread::sleep_for(1s);
			}

			pthread_create(&send_thread, NULL, &send, sender);

			try {
				while(1)
				{
					Message m = sender->getMessage();
					std::cout<<m.toString()<<std::endl;
				}
			}
			catch(ServerDisconnected& e ){
				std::cout<<"Server disconnected!";
				sender->stopServer();
				pthread_join(send_thread, NULL);
				sender->startServer();
				sender->closeConnection();
			}
		}
	}
	catch( ServerClosingSignal& e ) {
		std::cout<<"Received server closing signal"<<std::endl;
		return 0;
	}
	return 0;
}

int main(int argc, char** argv)
{
	pthread_t receiver, camera;
	MessageSender sender;
	handle_camera = true;

	pthread_create(&receiver, NULL, &receive, &sender);
	pthread_create(&camera, NULL, &cameraHandler, &sender);

	char t;
	std::cin>>t;
	sender.stopServer();

	pthread_join(receiver, NULL);
	handle_camera = false;
	pthread_join(camera, NULL);

    exit(0);
}
