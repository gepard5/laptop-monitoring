#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <pthread.h>
#include <thread>
#include <chrono>
#include <ctime>

#include "msg_sender.h"
#include "server_exceptions.h"

#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include "opencv2/opencv.hpp"

#include <boost/program_options.hpp>

namespace po = boost::program_options;

bool handle_camera;
int keyboard;

int movement_threshold = 5000;
double subtractor_rate = 0.01;
bool calculate_new_backgorund = false;
bool show_frames = false;

std::string getTimeString(){

	time_t rawtime;
	struct tm * timeinfo;
	char buffer[80];

	time (&rawtime);
	timeinfo = localtime(&rawtime);

	strftime(buffer,sizeof(buffer),"%d-%m-%Y_%I-%M-%S",timeinfo);
	std::string time_str(buffer);
	return time_str;

}

void* cameraHandler( void * s )
{
	MessageSender *sender = (MessageSender*) s ;

	using namespace cv;
	Mat frame; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method

	VideoCapture capture(0);

	auto pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	pMOG2->setShadowValue(0);

	int start, end;
	start = clock();
	while( handle_camera ) {
		while( handle_camera && !capture.isOpened()  )
		{
			std::cout << "Unable to open camera" << endl;
			Message m;
			m.commandName = "camerr";
			m.params["time"] = getTimeString();
			sender->pushQueueMessage(m);
			std::this_thread::sleep_for(1s);
			capture = VideoCapture(0);
		}

		while( handle_camera )
		{
			//read the current frame
			if(!capture.read(frame))
			{
				cerr << "Unable to read next frame." << endl;
				capture.release();
				break;
			}

			pMOG2->apply(frame, fgMaskMOG2, subtractor_rate);

			if( calculate_new_backgorund ) {
				pMOG2->apply(frame, fgMaskMOG2, 1);
				calculate_new_backgorund = false;

				Message m;
				m.commandName = "done";
				m.params["time"] = getTimeString();
				sender->pushQueueMessage(m);
			}

			GaussianBlur(frame, frame, Size(9, 9), 2, 2 );

			Mat gray = fgMaskMOG2.clone();
			Mat element = Mat::ones(5,5,CV_8UC1);

			// Apply the specified morphology operation
			morphologyEx( gray, gray, MORPH_CLOSE, element, Point(2,2), 2);
			morphologyEx( gray, gray, MORPH_OPEN, element, Point(2,2), 2);

			int non_zero = countNonZero( gray );
			end = clock();

			if( non_zero > movement_threshold && ( end - start ) > CLOCKS_PER_SEC ) {
				Message m;
				m.commandName = "event";
				m.params["time"] = getTimeString();
				m.params["movement"] = std::to_string(non_zero);
				sender->pushQueueMessage(m);
				std::cout<<"Message pushed "<<m.toString()<<std::endl;
				start = clock();
			}

			if( show_frames ) {
				imshow( "Result window", gray );
				imshow("Frame", frame);
				imshow("FG Mask MOG 2", fgMaskMOG2);
			}

			waitKey( 30 );
		}
	}
	capture.release();

	return 0;
}


void* send( void *  s)
{
	MessageSender *sender = (MessageSender*) s ;
	try {
		while( 1 )
		{
			sender->sendMessage();
			std::cout<<"Message sent"<<std::endl;
		}
	}
	catch( ServerDisconnected& e ) {
		std::cout<<"Server disconnected!"<<std::endl;
		return 0;
	}
	catch( ServerClosingSignal& e ) {
		std::cout<<"Received server closing signal"<<std::endl;
		return 0;
	}
	catch( ShutdownServerSignal& e ) {
		std::cout<<"Received server shutdown signal"<<std::endl;
		return 0;
	}
}


void* receive( void * s)
{
	using namespace std::chrono_literals;
	MessageSender *sender = (MessageSender*) s;
	pthread_t send_thread;

	try {
		while( 1 )
		{
			while( !sender->connect( 1 ) ) {
				std::this_thread::sleep_for(1s);
			}

			Message m1;
			m1.commandName = "auth";
			m1.params["name"] = "CM";
			m1.params["password"] = "pass";
			m1.params["localization"] = "PL";
			sender->sendMessage(m1);
			Message m2 = sender->getMessage();
			if(m2.commandName != "authServ"){
				throw ShutdownServerSignal();
			}

			pthread_create(&send_thread, NULL, &send, sender);

			try {
				while(1)
				{
					Message m = sender->getMessage();
					std::cout<<m.toString()<<std::endl;
					if(m.commandName == "close") {
						sender->stopServer();
						pthread_join(send_thread, NULL);
						sender->stopAll();
						return 0;
					}
				}
			}
			catch(ServerDisconnected& e ){
				std::cout<<"Server disconnected!";
				sender->stopServer();
				pthread_join(send_thread, NULL);
				sender->startServer();
				sender->closeConnection();
			}
		}
	}
	catch( ServerClosingSignal& e ) {
		std::cout<<"Received server closing signal"<<std::endl;

		if( !sender->isConnected() ) {
			sender->stopAll();
			return 0;
		}

		pthread_join(send_thread, NULL);
		sender->startServer();

		try {
			Message m;
			m.commandName = "end";
			m.params["time"] = getTimeString();
			sender->sendMessage(m);
		}
		catch ( ShutdownServerSignal& e) {
			sender->stopAll();
		 	pthread_join(send_thread, NULL);
		 	return 0;
		}

		sender->stopAll();
		return 0;
	}
	catch( ShutdownServerSignal& e ) {
		sender->stopAll();
		pthread_join(send_thread, NULL);
		return 0;
	}
}

int main(int argc, char** argv)
{
	pthread_t receiver, camera;
	MessageSender sender;
	handle_camera = true;

	po::variables_map vm;
	po::options_description desc("Allowed options");
	try
	{
		desc.add_options()
			("help,h", 																						"produce help message")
			("server,s",							po::value<std::string>(),		"set server address" )
			("port,p", 								po::value<int>(),					 	"set port")
			("show_frames,f",																			"set showing frames")
			("movement_threshold,t",	po::value<int>(),						"set movement_threshold")
			("subtractor_rate,r", 		po::value<double>(),				"set subtractor_rate")
		;

		po::store(po::parse_command_line(argc, argv, desc), vm);
		po::notify(vm);
	}

		catch( po::error& e)
	{
		std::cout<<e.what()<<std::endl;
		std::cout<<desc<<std::endl;
		return 0;
	}

	if ( vm.count("help") ) {
		std::cout<<desc<<std::endl;
		return 0;
	}

	if( vm.count("server") ) {
		sender.setServerAddress(vm["server"].as<std::string>());
		std::cout<<"address set to: "<<sender.getServerAddress()<<std::endl;
	}

	if( vm.count("port") ) {
		sender.setPort(vm["port"].as<int>());
		std::cout<<"port set to: "<<sender.getPort()<<std::endl;
	}

	if( vm.count("movement_threshold") ) {
		movement_threshold = vm["movement_threshold"].as<int>();
		std::cout<<"movement_threshold set to: "<<movement_threshold<<std::endl;
	}

	if( vm.count("subtractor_rate") ) {
		subtractor_rate = vm["subtractor_rate"].as<double>();
		std::cout<<"subtractor_rate set to: "<<subtractor_rate<<std::endl;
	}

	if( vm.count("show_frames") ) {
		show_frames = true;
		std::cout<<"show_frames set to: "<<show_frames<<std::endl;
	}


	pthread_create(&receiver, NULL, &receive, &sender);
	pthread_create(&camera, NULL, &cameraHandler, &sender);

	int source = sender.waitForServerClosignEvent();
	if( !source ) {
		std::string input;
		std::cin>>input;
		sender.stopServer();
	}

	source = sender.waitForServerClosignEvent();
	if( !source ) {
		std::string input;
		std::cin>>input;
		sender.stopAll();
	}

	handle_camera = false;
	pthread_join(receiver, NULL);
	pthread_join(camera, NULL);

    exit(0);
}
